/*
 * Funambol is a mobile platform developed by Funambol, Inc.
 * Copyright (C) 2008 Funambol, Inc.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License version 3 as published by
 * the Free Software Foundation with the addition of the following permission
 * added to Section 15 as permitted in Section 7(a): FOR ANY PART OF THE COVERED
 * WORK IN WHICH THE COPYRIGHT IS OWNED BY FUNAMBOL, FUNAMBOL DISCLAIMS THE
 * WARRANTY OF NON INFRINGEMENT  OF THIRD PARTY RIGHTS.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, see http://www.gnu.org/licenses or write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301 USA.
 *
 * You can contact Funambol, Inc. headquarters at 643 Bair Island Road, Suite
 * 305, Redwood City, CA 94063, USA, or at email address info@funambol.com.
 *
 * The interactive user interfaces in modified source and object code versions
 * of this program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU Affero General Public License version 3.
 *
 * In accordance with Section 7(b) of the GNU Affero General Public License
 * version 3, these Appropriate Legal Notices must retain the display of the
 * "Powered by Funambol" logo. If the display of the logo is not reasonably
 * feasible for technical reasons, the Appropriate Legal Notices must display
 * the words "Powered by Funambol".
 */

import java.util.List;
import java.util.Map;

import java.text.SimpleDateFormat;

import com.funambol.common.pim.utility.TimeUtils;

import com.funambol.framework.core.*;
import com.funambol.framework.core.Sync4jException;
import com.funambol.framework.engine.pipeline.OutputMessageProcessor;
import com.funambol.framework.engine.pipeline.MessageProcessingContext;
import com.funambol.framework.engine.pipeline.StopProcessingException;
import com.funambol.framework.logging.FunambolLogger;
import com.funambol.framework.logging.FunambolLoggerFactory;
import com.funambol.framework.tools.Base64;

/**
 * This synclet fixes an issue when a Funambol client v. 6.5.x receives a 
 * recurring event generated by a Funambol client v. 7.0.x (or phones).
 * The scenario is:
 * - create a recurring event with mask and with TZ US/Pacific (in order to have
 *   a change of the start day) on Funambol client v. 7.0.x
 * - sync with a server v. 7.0.x in SIF-E format
 * - sync with a Funambol client v. 6.5.x
 * The client v. 6.5.x is not able to handle a recurring event with timezone and
 * PatternStartDate in localtime and so the event is not right shown on device.
 * 
 * So, if the client is v. 6.5.x, if there is a recurrent event, if the item is
 * in SIF-E format, if StartDate is in UTC format and the PatternStartDate is
 * in local time, then:
 * - if the event StartDate is before the PatternStartDate
 *   - if the MonthOfYear is not 0, it is increased
 *   - if the DayOfMonth is not 0, it is increased
 *   - the DayOfWeekMask is shifted left
 *   - the PatternStartDate is set with the same value of the StartDate
 * - if the event StartDate is after the PatternStartDate
 *   - if the MonthOfYear is not 0, it is decreased
 *   - if the DayOfMonth is not 0, it is decreased
 *   - the DayOfWeekMask is shifted right
 *   - the PatternStartDate is set with the same value of the StartDate
 * otherwise nothing is done.
 * 
 * @version $Id: FixV65RecurrentEventout.bsh,v 1.1 2008-07-18 13:50:28 luigiafassina Exp $
 */
 
// ---------------------------------------------------------------- Private data
private final FunambolLogger log =
    FunambolLoggerFactory.getLogger("engine.pipeline");

// ------------------------------------------------------ Synclet implementation

/**
 * Process and manipulate the output message.
 *
 * @param mpc the message processing context
 * @param message the message to be processed
 *
 * @throws Sync4jException
 */
void postProcessMessage(MessageProcessingContext mpc,
                        SyncML message              )
throws Sync4jException {

    if (log.isTraceEnabled()) {
        log.trace("FixV65RecurrentEventout.postProcessMessage(...)");
    }

    List cmds = message.getSyncBody().getCommands();
    for (AbstractCommand bodyc : cmds) {

        if (bodyc instanceof Sync) {

            //
            // Processes incoming commands to identifier and separate the items.
            //
            List syncCmds = ((Sync)bodyc).getCommands();
            for (ItemizedCommand c : syncCmds) {

                //
                // Skip other commands than Add and Replace
                //
                if (!(Replace.COMMAND_NAME.equals(c.getName()) ||
                    Add.COMMAND_NAME.equals(c.getName()))      ) {
                    continue;
                }

                if (c.getMeta() == null) {
                    continue;
                }

                if (!"text/x-s4j-sife".equals(c.getMeta().getType())) {
                    continue;
                }

                boolean isEncoded = false;
                if ("b64".equals(c.getMeta().getFormat())) {
                    isEncoded = true;
                }
                List items = c.getItems();
                for (Item item: items) {
                    item = handleSIFCalendar(item, isEncoded);
                }//end for items
            }//end for commands
        }//end if Sync
    }
	
    throw new StopProcessingException("FixV65RecurrentEventout Synclet finished");
}

/**
 *
 * @param item the item to handle
 * @param isEncoded true if the item is b64 encoded
 * 
 * @return the modified data   
 */ 
Item handleSIFCalendar(Item item, boolean isEncoded) {

    String data = item.data.data;
    if (isEncoded) {
        data = new String(Base64.decode(data));
    }

    if (data.indexOf("<IsRecurring>1</IsRecurring>") == -1) {
        return item;
    }

    String startDate =
        data.substring(data.indexOf("<Start>" ) + 7,
                       data.indexOf("</Start>")    );

    String patternStartDate =
        data.substring(data.indexOf("<PatternStartDate>" ) + 18,
                       data.indexOf("</PatternStartDate>")     );

    if (startDate.endsWith("Z") && !patternStartDate.endsWith("Z")) {

        String monthOfYear  =
            data.substring(data.indexOf("<MonthOfYear>" ) + 13,
                           data.indexOf("</MonthOfYear>")     );
        String dayOfMonth    =
            data.substring(data.indexOf("<DayOfMonth>" ) + 12,
                           data.indexOf("</DayOfMonth>")     );
        String dayOfWeekMask =
            data.substring(data.indexOf("<DayOfWeekMask>" ) + 15,
                           data.indexOf("</DayOfWeekMask>")     );

        try {
            SimpleDateFormat dateFormatter = new SimpleDateFormat();
            dateFormatter.applyPattern(TimeUtils.getDateFormat(startDate));
            Date sd = dateFormatter.parse(startDate);

            dateFormatter.applyPattern(TimeUtils.getDateFormat(patternStartDate));
            Date psd = dateFormatter.parse(patternStartDate);

            int dayOfStartDate        = 
                Integer.parseInt(startDate.substring(6,8));
            int dayOfPatternStartDate = 
                Integer.parseInt(patternStartDate.substring(6,8));

            int monthOfYearStartDate  = 
                Integer.parseInt(startDate.substring(4,6));

            int r = sd.compareTo(psd);
            if (r == 0) {
                //sd is equals to psd
            } else {
                
                if (log.isTraceEnabled()) {
                    log.trace("Starting recurrent dates fixing...");
                }
                
                //
                // If the day of Start date is not equals the day of 
                // PatternStartDate means that there has been a shift to a day
                // ahead or behind the start date of the calendar.
                // So, if the MonthOfYear and DayOfMonth are not 0, they have to
                // be replaced with the day and the month specified in the Start
                // because the v.6.5.x clients want that all the recurrence
                // information are based on UTC dates (and the Start date is
                // just in UTC format).
                // The DayOfWeekMask has to be shifted backward (>> 1) when the
                // Start date is before the PatternStartDate (pay attention to
                // add 127 where its value is odd to fix rightly the mask)
                // The DayOfWeekMask has to be shifted  forward (<< 1) when the
                // Start date is after the PatternStartDate (pay attention to
                // subtract 127 when its value is greater then 127 in order to 
                // fix rightly the mask)
                //
                if (dayOfStartDate != dayOfPatternStartDate) {
                
                    if (!"0".equals(monthOfYear)) {
                        data = data.replaceFirst("<MonthOfYear>" + monthOfYear + "</MonthOfYear>",
                                                 "<MonthOfYear>" + monthOfYearStartDate + "</MonthOfYear>");
                    }
    
                    if (!"0".equals(dayOfMonth)) {
                        data = data.replaceFirst("<DayOfMonth>" + dayOfMonth + "</DayOfMonth>",
                                                 "<DayOfMonth>" + dayOfStartDate + "</DayOfMonth>");
                    }
                    
                    if (r > 0) {
                        //sd is after psd
                        int dwm = Integer.parseInt(dayOfWeekMask);
                        dwm = dwm << 1;
                        if (dwm > 127) {
                            dwm -= 127;
                        }
                        data = data.replaceFirst("<DayOfWeekMask>" + dayOfWeekMask + "</DayOfWeekMask>",
                                                 "<DayOfWeekMask>" + dwm + "</DayOfWeekMask>");
        
                    } else {
                        //sd is before psd
                        int dwm = Integer.parseInt(dayOfWeekMask);
                        if ((dwm & 1) == 1) {
                            dwm += 127;
                        }
                        dwm = dwm >> 1;
                        data = data.replaceFirst("<DayOfWeekMask>" + dayOfWeekMask + "</DayOfWeekMask>",
                                                 "<DayOfWeekMask>" + dwm + "</DayOfWeekMask>");
                    }
                }
            }
            
            data = data.replaceFirst("<PatternStartDate>" + patternStartDate + "</PatternStartDate>",
                                     "<PatternStartDate>" + startDate + "</PatternStartDate>");

            if (isEncoded) {
                data = new String(Base64.encode(data.getBytes()));
            }
            item.data.data = data;

        } catch(Exception e) {
            log.error("Error handling reccurrent SIF event", e);
        }
    }
    return item;

}


/**
 * Called at synclet's initialization time.
 */
void init() {
    // do nothing
}
